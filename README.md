# OpenAI Plugin For DevOps

## Generate YAML With Prompt Engineering

| NAME | PROMPT | DESCRIPTION | EXAMPLE | 
| ------------ | ------------ | ------------ | ------------ |
| app.yaml | Create an app gcr.io/level-skyline-417610/demo:v1.1.0 deployment with 1 replicas and port 8080 | App gcr.io/level-skyline-417610/demo:v1.1.0 with 1 replica and port 8080. | [app.yaml](./yaml/app.yaml) |
| app-livenessProbe.yaml | Create an app gcr.io/level-skyline-417610/demo:v1.1.0 deployment with 1 replicas and port 8080 add only liveness probe | A liveness probe in Kubernetes is used to determine whether a container is still alive and functioning. If the liveness probe fails, Kubernetes will restart the container to try to recover it. This is helpful to automatically restart unresponsive applications or those in a deadlock state. | [app-livenessProbe.yaml](./yaml/app-livenessProbe.yaml) |
| app-readinessProbe.yaml | Create an app gcr.io/level-skyline-417610/demo:v1.1.0 deployment with 1 replicas and port 8080 add readiness probe | 
A readiness probe in Kubernetes is used to determine whether a container is ready to serve traffic. If a readiness probe fails, Kubernetes stops routing traffic to the corresponding pod until the probe passes. This is particularly useful when you have rolling updates or need to ensure the container is fully initialized before handling requests. | [app-readinessProbe.yaml](./yaml/app-readinessProbe.yaml) |
| app-volumeMounts.yaml | Create an app gcr.io/level-skyline-417610/demo:v1.1.0 deployment with 1 replicas, volume data with host path /var/lib/app mount path /app and port 8080, add liveness /healthy readiness /ready | In Kubernetes, volumeMounts are used to mount a volume into a container, allowing the container to access a specific storage location. Volumes are shared resources between containers in a pod and can provide persistent storage or shared data. There are several types of volumes in Kubernetes, including emptyDir, hostPath, ConfigMap, Secret, PersistentVolumeClaim, and more. | [app-volumeMounts.yaml](./yaml/app-volumeMounts.yaml) |
| app-cronjob.yaml | Create cronjob app gcr.io/level-skyline-417610/demo:v1.1.0 with image bash that every 5 minutes print 'Hello world' | In Kubernetes, a CronJob allows you to run a scheduled job at specific times, similar to cron on UNIX/Linux systems. | [app-cronjob.yaml](./yaml/app-cronjob.yaml) |
| app-job.yaml | Create job app gcr.io/level-skyline-417610/demo:v1.1.0 for everyday database backup | Creating a Kubernetes job can be useful when you want to execute a one-time or batch task. A Job creates one or more pods and ensures they complete successfully. | [app-job.yaml](./yaml/app-job.yaml) |
| app-multicontainer.yaml | Create an app gcr.io/level-skyline-417610/demo:v1.1.0 of a multi-container Kubernetes pod in a Deployment, with one container running an application and another container serving as a sidecar. | Creating a multi-container application in Kubernetes allows you to run several containers within the same pod, facilitating inter-container communication, sharing storage, or running sidecar containers for auxiliary tasks like logging, monitoring, or authentication. | [app-multicontainer.yaml](./yaml/app-multicontainer.yaml) |
| app-resources.yaml | Create an app gcr.io/level-skyline-417610/demo:v1.1.0 with resource limits and requests define the computational resources (like CPU and memory) that a container can use | Resource requests and limits in Kubernetes define the computational resources (CPU and memory) that a container is allocated. Requests indicate the minimum resources a container requires, while limits define the maximum resources a container is allowed to consume. Properly setting these ensures that containers don't use excessive resources and allows Kubernetes to efficiently schedule pods. | [app-resources.yaml](./yaml/app-resources.yaml) |
| app-secret-env.yaml | Create a secret to store a database password and injects it into a container from the image gcr.io/level-skyline-417610/demo:v1.1.0. | In Kubernetes, secrets are used to securely store sensitive information like passwords, tokens, or other confidential data. When using secrets, you can inject them into pods as environment variables, making them accessible to containers while keeping the data encrypted within the cluster. | [app-secret-env.yaml](./yaml/app-secret-env.yaml) |